# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a **prototype** implementation of an edge device authentication and authorization system with three main components:

1. **Auth Manager** (FastAPI service) - Handles device registration, approval workflows, JWT token issuance, and certificate lifecycle tracking
2. **Agent** (Python module) - Lightweight security module that runs on edge devices, handles registration, token refresh, and publishes metadata to message bus
3. **Dashboard** (Streamlit) - Admin interface for approving/revoking devices and monitoring system state

The system demonstrates:
- mTLS-based mutual authentication between all components
- Device registration with admin approval gate
- JWT token-based authorization
- TLS-secured AMQP messaging via RabbitMQ with automatic reconnect and local buffering
- Key rotation resilience (non-disruptive reconnect during certificate rotation)

## Common Commands

### Initial Setup
```bash
# Generate all required certificates (must be done first)
cd ops
python gen_certs.py --out ../certs --cn-manager manager.local --cn-admin admin.local --cn-agent agent-001.local
cd ..
```

### Running the System
```bash
# Start all services (RabbitMQ, Manager, Dashboard, Agent)
docker compose up --build

# Start services in background
docker compose up --build -d

# Stop all services
docker compose down

# View logs
docker compose logs -f
docker compose logs -f manager    # specific service
```

### Agent Operations
```bash
# Run agent manually (inside agent container)
docker compose exec agent python -m agent.run --device-id agent-001 --site demo --group g1

# Run agent with different device ID
docker compose exec agent python -m agent.run --device-id agent-002 --site prod --group g2
```

### Accessing Services
- **Dashboard**: http://localhost:8501
- **Manager API**: https://localhost:8443 (requires mTLS client cert)
- **RabbitMQ Management**: http://localhost:15672 (use edge-agent credentials from RABBITMQ_EDGE_PASSWORD)

### Database
```bash
# SQLite database is stored in mounted volume
ls -la data/manager.db
sqlite3 data/manager.db "SELECT * FROM devices;"
```

## Architecture

### Device Lifecycle Flow
1. **Boot** → Agent starts with pre-installed client certificates
2. **Register** → Agent calls `/device/register` with device metadata (namespace = `{domain}/{site}/{group}/{device_id}`)
3. **Pending** → Device enters `PENDING` state, waiting for admin approval
4. **Approve** → Admin uses Dashboard to approve device via `/device/approve`
5. **Auth** → Agent polls `/auth/token` until approval succeeds, receives JWT
6. **Data Exchange** → Agent publishes metadata to RabbitMQ `agent.metadata` queue

### mTLS Certificate Structure
All certificates are generated by `ops/gen_certs.py` and stored in `certs/` directory:
- **CA**: Root certificate authority (self-signed)
- **Manager**: Server cert + CA for HTTPS API
- **Admin**: Client cert + CA for Dashboard → Manager communication
- **Agent**: Client cert + CA for Agent → Manager communication
- **RabbitMQ**: Server cert + CA for TLS AMQP

Each component verifies peers using the shared CA certificate.

### Service Architecture

**Manager Service** (`services/manager/`):
- `main.py`: FastAPI app with endpoints for device lifecycle, auth, and cert tracking
- `db.py`: SQLAlchemy async models (`Device`, `CertState`) and database operations
- `models.py`: Pydantic request/response models
- `security.py`: JWT issuance and validation (HS256)
- Admin actions require `X-Admin-Token` header (prototype: env var `ADMIN_TOKEN`)

**Agent Module** (`services/agent/agent/`):
- `run.py`: Main agent loop - register, wait for approval, obtain token, publish metadata
- `client.py`: HTTP client with mTLS and retry/backoff via `tenacity`
- `amqp_pub.py`: `SecurePublisher` class - TLS AMQP connection with automatic reconnect and local buffering
- `buffer.py`: `JsonlBuffer` - persistent JSONL file buffer for offline message storage
- `consume_demo.py`: Example consumer for reading from RabbitMQ (not used in main flow)

**Dashboard** (`services/dashboard/`):
- `app.py`: Streamlit UI showing device list, admin actions (approve/revoke), and cert operations
- Uses mTLS to communicate with Manager API

### Message Bus Design
- Agent publishes to RabbitMQ queue `agent.metadata` over TLS (port 5671)
- Publisher implements automatic reconnection with exponential backoff (up to 30 attempts)
- Messages are buffered locally to `{AGENT_BUFFER_DIR}/unsent.jsonl` during disconnections
- Buffer is flushed (up to 200 messages) on reconnect
- This design ensures no data loss during network failures or key rotation

### Device Namespace Convention
Devices are identified by hierarchical namespace: `{domain}/{site}/{group}/{device_id}`
- **domain**: Tenant/organization (default: "default")
- **site**: Physical location
- **group**: Logical grouping
- **device_id**: Unique device identifier

Example: `default/demo/g1/agent-001`

### Security Patterns

**JWT Token Flow**:
- Tokens are issued only to `APPROVED` devices
- Token subject (`sub`) is the device namespace
- Tokens include `roles: ["agent"]` for future RBAC
- TTL configured via `JWT_TTL_SECONDS` env var (default: 900s / 15min)
- Secret is generated randomly on startup (prototype) or via `JWT_SECRET` env var

**Admin Authorization**:
- Dashboard sends `X-Admin-Token` header for privileged operations
- Prototype uses static token from env var (default: "dev-admin-token")
- Production should use OIDC/mTLS with RBAC

**Certificate Lifecycle** (Prototype):
- `/cert/issue` and `/cert/revoke` endpoints track cert status in database
- Actual CSR-based certificate issuance is out of scope for this prototype
- Real system would integrate with PKI/CA for signing

## Environment Variables

**Manager**:
- `DB_URL`: SQLAlchemy connection string (default: `sqlite+aiosqlite:////data/manager.db`)
- `JWT_ISSUER`: JWT issuer claim (default: "edge-auth-manager")
- `JWT_AUDIENCE`: JWT audience claim (default: "edge-agents")
- `JWT_TTL_SECONDS`: Token validity period (default: "900")
- `JWT_SECRET`: HMAC secret for signing (random if not set)
- `ADMIN_TOKEN`: Admin authorization token (default: "dev-admin-token")
- `CERTS_DIR`: Path to certificates directory (default: "/certs")

**Agent**:
- `MANAGER_BASE_URL`: Manager API URL (default: "https://localhost:8443")
- `AMQP_URL`: RabbitMQ connection string (default: "amqps://edge-agent:${RABBITMQ_EDGE_PASSWORD}@localhost:5671/")
- `CERTS_DIR`: Path to certificates directory (default: "/certs")
- `AGENT_BUFFER_DIR`: Local buffer directory (default: "/buffer")

**RabbitMQ**:
- `RABBITMQ_EDGE_PASSWORD`: Password for edge-agent user (default: "edge-secure-password-change-me")

**Dashboard**:
- `MANAGER_BASE_URL`: Manager API URL (default: "https://localhost:8443")
- `CERTS_DIR`: Path to certificates directory (default: "/certs")
- `ADMIN_TOKEN`: Admin authorization token (default: "dev-admin-token")

## Key Rotation Demo

See `ops/rotate_demo.md` for full procedure. Summary:
1. Start stack and verify agent is publishing messages
2. Replace RabbitMQ server cert files in `certs/rabbitmq/`
3. Restart RabbitMQ container: `docker compose restart rabbitmq`
4. Agent detects disconnect, buffers to local JSONL file, reconnects automatically
5. Buffered messages are flushed after successful reconnect

## Database Schema

**devices** table:
- `namespace` (unique): Device identifier
- `status`: PENDING | APPROVED | REVOKED
- `hw_fingerprint`: Device hardware fingerprint hash
- `agent_version`: Agent software version
- `last_seen`: Last activity timestamp

**certs** table:
- `namespace` (unique): Device identifier
- `status`: ISSUED | REVOKED | UNKNOWN
- `not_after`: Certificate expiration timestamp

## Security Features

### Container Security
All containers run as **non-root users** for security:
- Manager: runs as user `manager` (UID 1001)
- Agent: runs as user `agent` (UID 1002)
- Dashboard: runs as user `dashboard` (UID 1003)

### RabbitMQ Security
- Default `guest` user is **deleted** on initialization
- Dedicated `edge-agent` user with limited permissions
- Password configurable via `RABBITMQ_EDGE_PASSWORD` environment variable
- Initialization handled by `ops/rabbitmq/init.sh`

### Token Management
- Tokens expire after 15 minutes (900s) by default
- Agent automatically **refreshes tokens** at 80% of TTL (12 minutes)
- No service interruption during token refresh
- Refresh logic in `services/agent/agent/run.py:48-63`

### TLS Enforcement
- Manager: HTTPS only, no HTTP listener
- RabbitMQ: TLS-only AMQP (TCP listener disabled)
- All inter-service communication encrypted

## Development Notes

- **Python 3.10+** required
- All services use async/await patterns extensively
- Database operations use SQLAlchemy async with aiosqlite
- HTTP client uses `httpx` with mTLS configuration
- AMQP client uses `aiormq` for async RabbitMQ interaction
- Retry logic implemented with `tenacity` library (exponential backoff with jitter)
- No pytest/tests in this prototype - focused on demonstrating architecture

## Container Structure

Each service has its own `Dockerfile` in `services/{service}/`:
- Manager: FastAPI with uvicorn, mTLS server config
- Agent: Runs agent loop, keeps container alive
- Dashboard: Streamlit server

Services depend on shared volumes:
- `./certs:/certs:ro` - Read-only certificate access
- `./data:/data` - Persistent database storage (manager)
- `./data/agent_buffer:/buffer` - Persistent message buffer (agent)

All containers run with non-root users and appropriate file permissions set at build time.
